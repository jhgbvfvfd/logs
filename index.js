
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import os from "os";
import readline from "readline";
import { fileURLToPath } from "url";

// =============== CONFIG ===============
const SEARCH_DIR = "cmdlo";
const TARGET_PATHS = [
  "/storage/emulated/0/Download",  // Android Download folder
  "/storage/emulated/0/Telegram/Telegram Files/", // Telegram Files folder
  os.homedir() + "/Downloads",     // User Downloads folder
  "/tmp/downloads"                 // Temporary downloads folder
];
const CREDIT_NAME = "CyberScience";
const VERSION = "2.0 Elite";

// === ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏£‡πá‡∏ß ===
const PARALLEL_FILES = Math.max(8, Math.min(os.cpus().length * 3, 24));
const READ_CHUNK_SIZE = 2 * 1024 * 1024;     // 2MB/‡∏ä‡∏±‡∏á‡∏Å‡πå
const RESULT_DEDUPE = false;                 // ‡∏õ‡∏¥‡∏î dedupe ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏ß

// =============== PATH/UTILS ===============
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const searchDirPath = path.join(__dirname, SEARCH_DIR);

// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ü‡∏ã readline
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// ‡∏™‡∏µ ANSI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏° + ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏û‡∏¥‡πÄ‡∏®‡∏©
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  italic: '\x1b[3m',
  underline: '\x1b[4m',
  blink: '\x1b[5m',
  reverse: '\x1b[7m',
  strikethrough: '\x1b[9m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  bgBlue: '\x1b[44m',
  bgGreen: '\x1b[42m',
  bgRed: '\x1b[41m',
  bgYellow: '\x1b[43m',
  bgMagenta: '\x1b[45m',
  bgCyan: '\x1b[46m',
  bgWhite: '\x1b[47m',
  bgBlack: '\x1b[40m',
  purple: '\x1b[35m',
  orange: '\x1b[38;5;208m',
  // Gradient Colors
  neonCyan: '\x1b[38;5;51m',
  neonGreen: '\x1b[38;5;46m',
  neonPink: '\x1b[38;5;201m',
  neonBlue: '\x1b[38;5;33m',
  gold: '\x1b[38;5;220m',
  silver: '\x1b[38;5;7m',
  hotPink: '\x1b[38;5;198m',
  electricBlue: '\x1b[38;5;27m',
  crimson: '\x1b[38;5;160m'
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏µ + ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏û‡∏¥‡πÄ‡∏®‡∏©
function colorLog(text, color = colors.white) {
  console.log(color + text + colors.reset);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Holographic Effect
function hologramText(text, delay = 100) {
  return new Promise((resolve) => {
    const holoColors = [colors.neonCyan, colors.neonPink, colors.neonGreen, colors.electricBlue, colors.gold];
    let colorIndex = 0;
    const interval = setInterval(() => {
      process.stdout.write('\r' + holoColors[colorIndex] + colors.bright + text + colors.reset);
      colorIndex = (colorIndex + 1) % holoColors.length;
    }, delay);
    
    setTimeout(() => {
      clearInterval(interval);
      console.log('\r' + colors.neonCyan + colors.bright + text + colors.reset);
      resolve();
    }, delay * holoColors.length * 2);
  });
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Glow Effect
function glowEffect(text, color = colors.neonCyan) {
  const glow = color + colors.bright + colors.underline;
  return glow + "‚ñë‚ñí‚ñì‚ñà " + text + " ‚ñà‚ñì‚ñí‚ñë" + colors.reset;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Matrix Digital Rain
async function digitalRain(duration = 2000) {
  const chars = "01„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥‚Äª‚àÄ‚àÖ‚àÜ‚àá‚àà‚àâ‚àã‚àå‚àé‚àè‚àë‚àö‚àû‚à´‚âà‚â†‚â§‚â•";
  const width = Math.min(process.stdout.columns || 80, 70);
  const height = 15;
  const drops = Array(width).fill(0);
  
  const rainInterval = setInterval(() => {
    let output = '';
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (drops[x] === y) {
          const char = chars[Math.floor(Math.random() * chars.length)];
          if (y === 0) output += colors.neonGreen + colors.bright + char + colors.reset;
          else if (y < 3) output += colors.green + colors.bright + char + colors.reset;
          else output += colors.green + colors.dim + char + colors.reset;
        } else {
          output += ' ';
        }
      }
      output += '\n';
    }
    
    console.log('\x1b[H\x1b[2J' + output); // Clear screen and move cursor to top
    
    for (let i = 0; i < width; i++) {
      if (drops[i] > height && Math.random() > 0.975) {
        drops[i] = 0;
      }
      drops[i]++;
    }
  }, 100);
  
  setTimeout(() => {
    clearInterval(rainInterval);
    console.clear();
  }, duration);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Cyber Wave Effect
function cyberWave(text) {
  const wave = "‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ";
  return colors.neonCyan + colors.bright + wave + " " + text + " " + wave + colors.reset;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏ö‡∏ö
function getSystemInfo() {
  const platform = os.platform();
  const arch = os.arch();
  const totalRAM = (os.totalmem() / 1024 / 1024 / 1024).toFixed(1);
  const freeRAM = (os.freemem() / 1024 / 1024 / 1024).toFixed(1);
  const cpus = os.cpus();
  const cpuModel = cpus[0]?.model || "Unknown";
  const cpuCores = cpus.length;
  const uptime = os.uptime();
  const loadAvg = os.loadavg();

  return {
    platform,
    arch,
    totalRAM,
    freeRAM,
    cpuModel: cpuModel.slice(0, 30),
    cpuCores,
    uptime,
    loadAvg: loadAvg[0].toFixed(2),
    hostname: os.hostname()
  };
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
function detectDevice() {
  const userAgent = process.env.HTTP_USER_AGENT || "";
  const terminalWidth = process.stdout.columns || 80;
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å terminal width ‡πÅ‡∏•‡∏∞ environment
  if (terminalWidth < 100) {
    return { type: "üì± Mobile/Tablet", icon: "üì±" };
  } else if (terminalWidth > 120) {
    return { type: "üñ•Ô∏è Desktop", icon: "üñ•Ô∏è" };
  } else {
    return { type: "üíª Laptop", icon: "üíª" };
  }
}

async function printBanner() {
  console.clear();
  const sysInfo = getSystemInfo();
  const device = detectDevice();
  
  // Mobile-optimized banner
  console.log(createMobileBorder("üöÄ CYBER ELITE", "‚ñì", colors.neonCyan + colors.bright));
  await new Promise(resolve => setTimeout(resolve, 300));
  
  console.log();
  await hologramText(`${CREDIT_NAME} v${VERSION}`, 60);
  console.log();
  
  console.log(colors.neonCyan + colors.bright + "‚ö° Search Engine Elite ‚ö°" + colors.reset);
  console.log();
  
  // Compact system info for mobile
  const quickStats = [
    `${device.icon} ${device.type}`,
    `üíæ ${sysInfo.freeRAM}/${sysInfo.totalRAM}GB`,
    `‚öôÔ∏è ${sysInfo.cpuCores} cores ‚Ä¢ üìä ${sysInfo.loadAvg}%`
  ];
  
  console.log(createMobileBox("üíª ‡∏£‡∏∞‡∏ö‡∏ö", quickStats, colors.gold));
  
  // Compact status indicators
  console.log();
  console.log(colors.neonGreen + "‚óè ONLINE" + colors.reset + " " + 
              colors.neonBlue + "‚óè AI ACTIVE" + colors.reset + " " + 
              colors.gold + "‚óè SECURE" + colors.reset);
  console.log();
}

async function printMenu() {
  console.log(createMobileBorder("üéØ ‡πÄ‡∏°‡∏ô‡∏π ELITE", "‚ïê", colors.neonCyan + colors.bright));
  await new Promise(resolve => setTimeout(resolve, 200));
  
  console.log();
  
  // Mobile-friendly menu items
  const menuItems = [
    `${colors.bgGreen + colors.white} 1 ${colors.reset} üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•`,
    `${colors.bgBlue + colors.white} 2 ${colors.reset} üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏∞‡∏ö‡∏ö`,
    `${colors.bgMagenta + colors.white} 3 ${colors.reset} ‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤`,
    `${colors.bgYellow + colors.white} 4 ${colors.reset} üí° ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô`,
    `${colors.bgRed + colors.white} 5 ${colors.reset} üö™ ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö`
  ];
  
  console.log(createMobileBox("üéÆ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏°‡∏ô‡∏π", menuItems, colors.neonCyan));
  
  console.log();
  console.log(createMobileBorder("‚ö° SELECT ‚ö°", "‚ñí", colors.yellow));
  console.log();
}

if (!fs.existsSync(searchDirPath)) {
  fs.mkdirSync(searchDirPath, { recursive: true });
  colorLog(`‚úÖ [INIT] ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå '${SEARCH_DIR}' ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢`, colors.green);
}

function looksLikeUrl(s) {
  return /^https?:\/\/|^[\w.-]+\.[a-z]{2,}(?:\/|$)/i.test(s);
}

function extractHostname(input) {
  try {
    let u = input.trim();
    if (!/^https?:\/\//i.test(u)) u = "http://" + u;
    const url = new URL(u);
    return url.hostname.toLowerCase();
  } catch { return ""; }
}

function sanitizeFileName(name) {
  return (name || "file.txt").replace(/[/:*?"<>|]/g, "_").replace(/\s+/g, " ").trim().slice(0, 200);
}

// =============== ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå ===============
async function getAllTxtFiles(dirPath) {
  let out = [];
  try {
    const entries = await fsp.readdir(dirPath, { withFileTypes: true });
    for (const e of entries) {
      const full = path.join(dirPath, e.name);
      if (e.isDirectory()) out = out.concat(await getAllTxtFiles(full));
      else if (e.isFile() && e.name.toLowerCase().endsWith(".txt")) out.push(full);
    }
  } catch (e) {
    colorLog(`‚ùóÔ∏è[ERR] ‡∏≠‡πà‡∏≤‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: ${dirPath}`, colors.red);
  }
  return out;
}

async function getAllTxtFilesFromTargets() {
  let allFiles = [];
  
  for (const targetPath of TARGET_PATHS) {
    try {
      // Check if path exists
      await fsp.access(targetPath);
      const files = await getAllTxtFiles(targetPath);
      allFiles = allFiles.concat(files);
      colorLog(`‚úÖ ‡∏™‡πÅ‡∏Å‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå: ${targetPath} (‡∏û‡∏ö ${files.length} ‡πÑ‡∏ü‡∏•‡πå)`, colors.green);
    } catch (e) {
      colorLog(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á: ${targetPath}`, colors.yellow);
    }
  }
  
  return allFiles;
}

async function searchInFileStream(filePath, keyword, onBatch) {
  const needle = keyword.toLowerCase();
  const stream = fs.createReadStream(filePath, { encoding: "utf-8", highWaterMark: READ_CHUNK_SIZE });
  const fileRl = readline.createInterface({ input: stream, crlfDelay: Infinity });

  let batch = [];
  let count = 0;
  const flush = () => {
    if (!batch.length) return;
    onBatch(batch);
    count += batch.length;
    batch = [];
  };

  return new Promise((resolve) => {
    fileRl.on("line", (line) => {
      if (line.toLowerCase().includes(needle)) {
        let processedLine = line;
        const parts = line.split(':');
        if (parts.length >= 3) {
          processedLine = parts.slice(-2).join(':');
        }
        batch.push(processedLine);
        if (batch.length >= 200) flush();
      }
    });
    fileRl.on("close", () => { flush(); resolve(count); });
    fileRl.on("error", (e) => { colorLog(`‚ùóÔ∏è[ERR] ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: ${filePath}`, colors.red); flush(); resolve(count); });
  });
}

async function mapLimit(items, limit, worker) {
  const ret = new Array(items.length);
  let i = 0;
  async function next() {
    if (i >= items.length) return;
    const idx = i++;
    ret[idx] = await worker(items[idx], idx);
    return next();
  }
  const starters = Array.from({ length: Math.min(limit, items.length) }, () => next());
  await Promise.all(starters);
  return ret;
}

async function performSearch(keyword, explicitOutName = "") {
  const files = await getAllTxtFilesFromTargets();
  const t0 = Date.now();

  // Progress Bar Animation
  const progressChars = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'];
  let progressIndex = 0;
  const progressInterval = setInterval(() => {
    process.stdout.write(`\r${colors.yellow}${progressChars[progressIndex]} ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏ü‡∏•‡πå... ${colors.cyan}[${files.length} files]${colors.reset}`);
    progressIndex = (progressIndex + 1) % progressChars.length;
  }, 100);

  const baseName = explicitOutName ? sanitizeFileName(explicitOutName) : `results-${Date.now()}.txt`;
  const outPath = path.join(os.tmpdir(), baseName);
  const ws = fs.createWriteStream(outPath, { encoding: "utf8" });

  let totalLines = 0;
  let filesWithHits = 0;
  const seen = RESULT_DEDUPE ? new Set() : null;

  await mapLimit(files, PARALLEL_FILES, async (f) => {
    let localCount = 0;
    await searchInFileStream(f, keyword, (batch) => {
      if (RESULT_DEDUPE) {
        const filtered = [];
        for (const ln of batch) if (!seen.has(ln)) { seen.add(ln); filtered.push(ln); }
        if (filtered.length) { ws.write(filtered.join("\n") + "\n"); localCount += filtered.length; }
      } else {
        ws.write(batch.join("\n") + "\n");
        localCount += batch.length;
      }
    });
    if (localCount > 0) filesWithHits++;
    totalLines += localCount;
  });

  clearInterval(progressInterval);
  process.stdout.write("\r" + " ".repeat(50) + "\r");
  
  await new Promise((r) => ws.end(r));
  const elapsedSec = (Date.now() - t0) / 1000;

  if (totalLines === 0) {
    await fsp.unlink(outPath).catch(() => {});
    return { resultPath: null, totalLines, filesWithHits: 0, totalFilesScanned: files.length, elapsedSec };
  }
  return { resultPath: outPath, totalLines, filesWithHits, totalFilesScanned: files.length, elapsedSec };
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤
function hhmmss(totalSec) {
  const s = Math.max(0, Math.floor(totalSec));
  const h = String(Math.floor(s / 3600)).padStart(2, "0");
  const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
  const ss = String(s % 60).padStart(2, "0");
  return `${h}:${m}:${ss}`;
}

// =============== MOBILE-OPTIMIZED UI FUNCTIONS ===============
function getMobileWidth() {
  return Math.min(process.stdout.columns || 80, 50); // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
}

function createMobileBorder(text, borderChar = "‚îÄ", color = colors.cyan) {
  const width = getMobileWidth();
  const padding = Math.max(0, Math.floor((width - text.length) / 2));
  const border = borderChar.repeat(width);
  const centeredText = " ".repeat(padding) + text + " ".repeat(padding);
  return color + border + "\n" + centeredText.slice(0, width) + "\n" + border + colors.reset;
}

function createMobileBox(title, content, color = colors.cyan) {
  const width = getMobileWidth();
  const topBorder = "‚ï≠" + "‚îÄ".repeat(width - 2) + "‚ïÆ";
  const bottomBorder = "‚ï∞" + "‚îÄ".repeat(width - 2) + "‚ïØ";
  const titleLine = "‚îÇ" + title.slice(0, width - 4).padEnd(width - 2) + "‚îÇ";
  
  let result = color + topBorder + "\n" + titleLine + "\n";
  
  if (Array.isArray(content)) {
    content.forEach(line => {
      const displayLine = "‚îÇ " + line.slice(0, width - 4).padEnd(width - 3) + "‚îÇ";
      result += displayLine + "\n";
    });
  } else {
    const displayLine = "‚îÇ " + content.slice(0, width - 4).padEnd(width - 3) + "‚îÇ";
    result += displayLine + "\n";
  }
  
  result += bottomBorder + colors.reset;
  return result;
}

async function mobileSearchAnimation() {
  console.clear();
  
  // Mobile-friendly search animation
  const searchFrames = [
    "üîç ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤...",
    "üì° ‡∏™‡πÅ‡∏Å‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...", 
    "‚ö° ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...",
    "üéØ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...",
    "üí´ ‡πÄ‡∏Å‡∏∑‡∏≠‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß...",
    "‚ú® ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!"
  ];
  
  for (let i = 0; i < searchFrames.length; i++) {
    console.clear();
    console.log(createMobileBorder("üöÄ CYBER SEARCH", "‚ñì", colors.neonCyan));
    console.log();
    
    const progressBar = "‚ñà".repeat(Math.floor((i + 1) / searchFrames.length * 20));
    const emptyBar = "‚ñë".repeat(20 - progressBar.length);
    
    console.log(colors.yellow + colors.bright + "  " + searchFrames[i] + colors.reset);
    console.log(colors.cyan + "  [" + progressBar + emptyBar + "] " + Math.floor((i + 1) / searchFrames.length * 100) + "%" + colors.reset);
    
    await new Promise(resolve => setTimeout(resolve, 300));
  }
}

// =============== MENU FUNCTIONS ===============
async function searchMenu() {
  console.clear();
  
  console.log(createMobileBorder("üîç SEARCH ENGINE", "‚ïê", colors.magenta + colors.bright));
  console.log();

  console.log(colors.yellow + colors.bright + "üí° ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:" + colors.reset);
  console.log(colors.cyan + "  üåê example.com" + colors.reset);
  console.log(colors.cyan + "  üìß admin@email.com" + colors.reset);
  console.log(colors.cyan + "  üîë password123" + colors.reset);
  console.log();

  const query = await new Promise((resolve) => {
    rl.question(colors.cyan + colors.bright + "üîë ‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤: " + colors.reset, resolve);
  });

  if (!query.trim()) {
    console.log(colors.red + colors.bright + "‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤!" + colors.reset);
    return;
  }

  const raw = query.trim();
  const isUrl = looksLikeUrl(raw);
  const host = isUrl ? extractHostname(raw) : "";
  const keyword = isUrl && host ? host : raw;

  // ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡πà‡∏ô‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
  await mobileSearchAnimation();

  const { resultPath, totalLines, filesWithHits, totalFilesScanned, elapsedSec } = 
    await performSearch(keyword);

  // ‡∏•‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
  console.clear();
  
  // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÅ‡∏ö‡∏ö‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
  console.log(createMobileBorder("üìä ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤", "‚ñì", colors.green + colors.bright));
  console.log();
  
  const resultData = [
    `üéØ ‡∏û‡∏ö: ${colors.yellow}${totalLines.toLocaleString()}${colors.reset} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`,
    `üìÅ ‡∏™‡πÅ‡∏Å‡∏ô: ${colors.cyan}${totalFilesScanned}${colors.reset} ‡πÑ‡∏ü‡∏•‡πå`,
    `üìÑ ‡πÄ‡∏à‡∏≠‡πÉ‡∏ô: ${colors.magenta}${filesWithHits}${colors.reset} ‡πÑ‡∏ü‡∏•‡πå`,
    `‚è±Ô∏è ‡πÄ‡∏ß‡∏•‡∏≤: ${colors.blue}${hhmmss(elapsedSec)}${colors.reset}`,
    `üè∑Ô∏è ‡πÇ‡∏î‡∏¢: ${colors.purple}${CREDIT_NAME}${colors.reset}`
  ];
  
  if (resultPath) {
    resultData.push(`üíæ ‡πÑ‡∏ü‡∏•‡πå: ${colors.orange}${path.basename(resultPath)}${colors.reset}`);
  }
  
  console.log(createMobileBox("üéØ ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå", resultData, colors.green));
  
  // ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
  if (totalLines > 0) {
    console.log();
    await hologramText("üéâ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!", 100);
  } else {
    console.log();
    console.log(colors.red + colors.bright + "üí≠ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤" + colors.reset);
  }
}

async function statsMenu() {
  console.clear();
  const sysInfo = getSystemInfo();
  const device = detectDevice();
  
  console.log(createMobileBorder("üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏∞‡∏ö‡∏ö", "‚ïê", colors.blue + colors.bright));
  console.log();

  console.log(colors.yellow + "üîÑ ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏∞‡∏ö‡∏ö..." + colors.reset);
  await new Promise(resolve => setTimeout(resolve, 800));

  const files = await getAllTxtFilesFromTargets();
  let totalSize = 0;

  for (const file of files) {
    try {
      const stats = await fsp.stat(file);
      totalSize += stats.size;
    } catch (e) {
      // ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
    }
  }

  console.clear();
  console.log(createMobileBorder("üìà ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö", "‚ñì", colors.cyan + colors.bright));
  console.log();
  
  const systemData = [
    `${device.icon} ${device.type}`,
    `üñ•Ô∏è ${sysInfo.hostname.slice(0,15)}`,
    `üíæ ${sysInfo.freeRAM}/${sysInfo.totalRAM}GB`,
    `‚öôÔ∏è ${sysInfo.cpuCores} cores`,
    `üèóÔ∏è ${sysInfo.platform}/${sysInfo.arch}`,
    `üìä Load: ${sysInfo.loadAvg}%`,
    `‚è∞ ${hhmmss(sysInfo.uptime)}`
  ];
  
  console.log(createMobileBox("üíª ‡∏£‡∏∞‡∏ö‡∏ö", systemData, colors.cyan));
  console.log();
  
  const dataStats = [
    `üìÅ ${SEARCH_DIR}`,
    `üìÑ ${files.length.toLocaleString()} ‡πÑ‡∏ü‡∏•‡πå`,
    `üíæ ${(totalSize / 1024 / 1024).toFixed(2)} MB`,
    `üîß ${PARALLEL_FILES} parallel`,
    `‚ö° ${(READ_CHUNK_SIZE / 1024 / 1024).toFixed(1)}MB chunks`
  ];
  
  console.log(createMobileBox("üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•", dataStats, colors.green));
}

async function settingsMenu() {
  console.clear();
  
  console.log(createMobileBorder("‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤", "‚ïê", colors.yellow + colors.bright));
  console.log();

  const configData = [
    `üóÇÔ∏è ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤: ${colors.cyan}${TARGET_PATHS.length} paths${colors.reset}`,
    `üì± Android: ${colors.orange}/storage/emulated/0/Download${colors.reset}`,
    `üë§ ‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏í‡∏ô‡∏≤: ${colors.magenta}${CREDIT_NAME}${colors.reset}`,
    `üîß Parallel: ${colors.green}${PARALLEL_FILES}${colors.reset}`,
    `‚ö° Chunk: ${colors.yellow}${(READ_CHUNK_SIZE / 1024 / 1024).toFixed(1)}MB${colors.reset}`,
    `üîÑ Dedupe: ${colors.blue}${RESULT_DEDUPE ? '‡πÄ‡∏õ‡∏¥‡∏î' : '‡∏õ‡∏¥‡∏î'}${colors.reset}`
  ];
  
  console.log(createMobileBox("üìã ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤", configData, colors.yellow));
  console.log();
  console.log(colors.dim + "üí° ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå index.js" + colors.reset);
}

async function helpMenu() {
  console.clear();
  
  console.log(createMobileBorder("üí° ‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "‚ïê", colors.green + colors.bright));
  console.log();

  console.log(colors.yellow + colors.bright + "üìñ ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ:" + colors.reset);
  console.log();
  
  console.log(colors.cyan + "1Ô∏è‚É£ ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤:" + colors.reset);
  console.log("  ‚Ä¢ ‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤");
  console.log("  ‚Ä¢ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö URL ‡πÅ‡∏•‡∏∞‡∏≠‡∏µ‡πÄ‡∏°‡∏•");
  console.log("  ‚Ä¢ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö real-time");
  console.log();
  
  console.log(colors.cyan + "2Ô∏è‚É£ ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:" + colors.reset);
  console.log("  üåê example.com");
  console.log("  üìß admin@email.com");
  console.log("  üîë password123");
  console.log();
  
  console.log(colors.cyan + "3Ô∏è‚É£ ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:" + colors.reset);
  console.log("  ‚Ä¢ ‡∏ß‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .txt ‡πÉ‡∏ô cmdlo");
  console.log("  ‚Ä¢ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏¢‡πà‡∏≠‡∏¢");
  console.log("  ‚Ä¢ ‡∏™‡πÅ‡∏Å‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥");
  console.log();
  
  console.log(colors.purple + colors.bright + `üíù ${CREDIT_NAME} Elite Team` + colors.reset);
}

// =============== MAIN LOOP ===============
async function mainLoop() {
  while (true) {
    await printBanner();
    await printMenu();

    const choice = await new Promise((resolve) => {
      rl.question(colors.bright + colors.cyan + "üéØ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏°‡∏ô‡∏π (1-5): " + colors.reset, resolve);
    });

    console.log();

    switch (choice.trim()) {
      case '1':
        await searchMenu();
        break;
      case '2':
        await statsMenu();
        break;
      case '3':
        await settingsMenu();
        break;
      case '4':
        await helpMenu();
        break;
      case '5':
        colorLog("‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ", colors.green + colors.bright);
        colorLog("‚îÇ                        üëã ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô!                             ‚îÇ", colors.green + colors.bright);
        colorLog("‚îÇ                                                                         ‚îÇ", colors.green);
        colorLog(`‚îÇ  üíù ${CREDIT_NAME} Elite - ‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á            ‚îÇ`, colors.green);
        colorLog("‚îÇ                                                                         ‚îÇ", colors.green);
        colorLog("‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ", colors.green + colors.bright);
        rl.close();
        process.exit(0);
        break;
      default:
        colorLog("‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏°‡∏ô‡∏π 1-5 ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô!", colors.red + colors.bright);
    }

    console.log();
    await new Promise((resolve) => {
      rl.question(colors.dim + "‡∏Å‡∏î Enter ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å..." + colors.reset, resolve);
    });
  }
}

// =============== ULTIMATE STARTUP ANIMATION ===============
async function showStartupAnimation() {
  console.clear();
  
  // Phase 1: Holographic Boot Sequence (2.5s)
  console.log(cyberWave("INITIATING QUANTUM BOOT SEQUENCE"));
  await new Promise(resolve => setTimeout(resolve, 500));
  
  const initFrames = [
    "‚†ã ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ñ‡∏ß‡∏≠‡∏ô‡∏ï‡∏±‡∏°...",
    "‚†ô ‡πÇ‡∏´‡∏•‡∏î Neural Networks...", 
    "‚†π ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô AI Core...",
    "‚†∏ ‡∏™‡∏£‡πâ‡∏≤‡∏á Cyber Defense...",
    "‚†º ‡∏™‡πÅ‡∏Å‡∏ô Matrix Database...",
    "‚†¥ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Hologram Engine...",
    "‚†¶ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Cyber Space...",
    "‚†ß ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô!"
  ];
  
  for (let i = 0; i < initFrames.length; i++) {
    const holoColor = [colors.neonCyan, colors.neonPink, colors.neonGreen, colors.electricBlue][i % 4];
    process.stdout.write("\r" + holoColor + colors.bright + "üöÄ " + initFrames[i] + " " + "‚ñë‚ñí‚ñì‚ñà".repeat(i + 1) + colors.reset);
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  
  console.log("\n");
  
  // Phase 2: Epic ASCII Art with Holographic Effect (3s)
  await hologramText("CONSTRUCTING DIGITAL REALITY", 100);
  console.log();
  
  const asciiLines = [
    "",
    "   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó",
    "  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù",
    "  ‚ñà‚ñà‚ïë      ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ",
    "  ‚ñà‚ñà‚ïë       ‚ïö‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ",
    "  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó",
    "   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù",
    "",
    "        üî•üíÄ CYBER SCIENCE ELITE üíÄüî•",
    "     ‚ö°üåå Advanced Search Engine v2.0 üåå‚ö°",
    ""
  ];
  
  for (let i = 0; i < asciiLines.length; i++) {
    const line = asciiLines[i];
    const colors_array = [colors.neonCyan, colors.neonPink, colors.gold, colors.neonGreen, colors.electricBlue];
    const color = colors_array[i % colors_array.length];
    console.log(color + colors.bright + line + colors.reset);
    await new Promise(resolve => setTimeout(resolve, 180));
  }
  
  // Phase 3: Enhanced Matrix Rain Effect (2.5s)
  console.log(glowEffect("üåä MATRIX DIGITAL RAIN ACTIVATED"));
  await digitalRain(2500);
  
  // Phase 4: System Analysis with Holographic Status (1.5s)
  console.log(cyberWave("PERFORMING DEEP SYSTEM ANALYSIS"));
  
  const statusChecks = [
    { text: "QUANTUM CPU", status: "ONLINE", color: colors.neonGreen },
    { text: "NEURAL RAM", status: "OPTIMIZED", color: colors.neonBlue },
    { text: "CRYPTO STORAGE", status: "ENCRYPTED", color: colors.neonPink },
    { text: "CYBER NETWORK", status: "SECURED", color: colors.gold },
    { text: "AI DEFENSE", status: "MAXIMUM", color: colors.crimson }
  ];
  
  for (const check of statusChecks) {
    console.log(`${check.color}${colors.bright}‚ñì‚ñí‚ñë ${check.text}: ${colors.blink}${check.status}${colors.reset} ${check.color}‚ñë‚ñí‚ñì${colors.reset}`);
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  
  // Phase 5: Epic Countdown with Holographic Effects (2s)
  console.log("\n" + glowEffect("üéØ ENTERING CYBER DIMENSION"));
  const countdown = ["‚ñì‚ñì‚ñì", "‚ñì‚ñì‚ñë", "‚ñì‚ñë‚ñë", "üí• LAUNCH!"];
  
  for (const count of countdown) {
    process.stdout.write("\r" + colors.hotPink + colors.bright + colors.blink + "   ‚ó¢‚ó§ " + count + " ‚ó•‚ó£   " + colors.reset);
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  console.log("\n");
  
  // Phase 6: Ultimate Activation Flash (1s)
  const flashMessages = [
    "‚ö° QUANTUM SYSTEMS ACTIVATED ‚ö°",
    "üí´ HOLOGRAPHIC INTERFACE READY üí´", 
    "üöÄ CYBER ELITE ENGINE ONLINE üöÄ"
  ];
  
  for (let i = 0; i < 5; i++) {
    const msg = flashMessages[i % flashMessages.length];
    console.log(colors.bgWhite + colors.bright + colors.blink + "                    " + msg + "                    " + colors.reset);
    await new Promise(resolve => setTimeout(resolve, 150));
    process.stdout.write("\r" + " ".repeat(80) + "\r");
    await new Promise(resolve => setTimeout(resolve, 150));
  }
  
  // Final Welcome with Ultimate Style
  await hologramText("üéâ ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà CyberScience Elite Dimension! üéâ", 100);
  console.log();
  console.log(cyberWave("READY FOR QUANTUM OPERATIONS"));
  console.log("");
}

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°
(async () => {
  await showStartupAnimation();
  mainLoop().catch(console.error);
})();
